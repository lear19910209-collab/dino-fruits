<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>小恐龙躲水果 · 护盾&冲刺版</title>
<style>
  html,body{height:100%;margin:0;background:#0e0f13;color:#eef;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{display:flex;align-items:center;justify-content:center;height:100%}
  canvas{background:linear-gradient(180deg,#0b0c10 0%,#0e1016 100%);border:1px solid #222;box-shadow:0 10px 30px rgba(0,0,0,.6);touch-action:none}
  .tag{position:fixed;left:12px;top:12px;font-size:12px;opacity:.85;background:rgba(255,255,255,.04);border:1px solid #2a2f3a;padding:6px 8px;border-radius:10px}
  .hud{position:fixed;left:50%;top:12px;transform:translateX(-50%);display:flex;gap:14px;align-items:center;font-weight:700;letter-spacing:.3px}
  .btnbar{position:fixed;right:12px;top:10px;display:flex;gap:8px}
  .iconbtn{width:36px;height:36px;border-radius:10px;border:1px solid #2a2f3a;background:rgba(255,255,255,.04);display:grid;place-items:center;cursor:pointer;user-select:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);visibility:hidden;opacity:0;transition:.2s}
  .show{visibility:visible;opacity:1}
  .card{background:#151a22;border:1px solid #2a2f3a;padding:18px 20px;border-radius:14px;text-align:center;max-width:92vw;color:#dfe7ff}
  .btn{display:inline-block;margin-top:12px;padding:10px 16px;border-radius:10px;border:1px solid #2a2f3a;background:#18202b;cursor:pointer;user-select:none}
  .small{opacity:.8;font-size:13px;margin-top:6px}
  .meter{position:fixed;right:12px;top:56px;width:120px;height:10px;border:1px solid #2a2f3a;border-radius:8px;background:rgba(255,255,255,.04);overflow:hidden}
  .meter>i{display:block;height:100%;background:#6ce1ff;transform-origin:left center;transition:width .1s}
  .shieldbar{position:fixed;right:12px;top:74px;width:120px;height:10px;border:1px solid #2a2f3a;border-radius:8px;background:rgba(255,255,255,.04);overflow:hidden}
  .shieldbar>i{display:block;height:100%;background:#7dffa5;transform-origin:left center;transition:width .1s}
</style>
</head>
<body>
  <div class="tag">🦖 Dino & Fruits · v3.0</div>

  <div class="hud">
    分数：<span id="score">0</span>
    <span>· 最高分：<span id="best">0</span></span>
    <span id="lives"></span>
  </div>

  <div class="btnbar">
    <div class="iconbtn" id="pauseBtn" title="暂停/继续">⏸️</div>
    <div class="iconbtn" id="muteBtn" title="静音/开音">🔊</div>
  </div>
  <!-- 冲刺冷却 -->
  <div class="meter" title="冲刺冷却（Shift）"><i id="dashFill" style="width:100%"></i></div>
  <!-- 护盾剩余 -->
  <div class="shieldbar" title="护盾剩余（拾取绿色道具）"><i id="shieldFill" style="width:0%"></i></div>

  <div class="wrap"><canvas id="game" width="460" height="760"></canvas></div>

  <div id="overlay" class="overlay">
    <div class="card">
      <h2 style="margin:6px 0 6px">小恐龙躲水果</h2>
      <div id="msg">方向键 ← → 移动；你有 <b>3</b> 条命。<br>拾取绿色道具获得 <b>5 秒护盾</b>；按 <b>Shift</b> 冲刺穿透水果（<b>3 秒冷却</b>）。</div>
      <div class="small">R 重开 · 空格暂停/继续 · 手机可左右拖拽 · 点开始会播放BGM</div>
      <div class="btn" id="start">开始游戏</div>
    </div>
  </div>

<script>
const canvas = document.getElementById('game');
const c = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const scoreEl = document.getElementById('score');
const bestEl  = document.getElementById('best');
const livesEl = document.getElementById('lives');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start');
const msgEl = document.getElementById('msg');
const pauseBtn = document.getElementById('pauseBtn');
const muteBtn = document.getElementById('muteBtn');
const dashFill = document.getElementById('dashFill');
const shieldFill = document.getElementById('shieldFill');

let keys = new Set();
let pointerX = null;
let state='menu'; // menu | play | pause | dead
let score=0, time=0, spawnTimer=0, powerTimer=0;
let best = Number(localStorage.getItem('dino_highscore')||0);
bestEl.textContent = best;

let lives = 3;
let invincible = 0; // 被击中后的短暂无敌
let blink = 0;      // 眨眼计时器

// 冲刺 & 护盾
let dashing = 0;             // 冲刺剩余秒
const DASH_DURATION = 0.35;
let dashCooldown = 0;        // 冷却剩余秒（0 可用）
const DASH_COOLDOWN = 3.0;

let shield = 0;              // 护盾剩余秒（>0 有效）
const SHIELD_GAIN = 5.0;

let fruits=[], powers=[];
const rnd=(a,b)=>Math.random()*(b-a)+a;

// 音频（纯代码合成）
let audioCtx = null, masterGain = null, bgmTimer = null, muted=false;
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.25;
  masterGain.connect(audioCtx.destination);
}
function tone(freq, dur=0.12, type='sine', vol=0.5) {
  if (!audioCtx || muted) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.value = 0;
  osc.connect(gain); gain.connect(masterGain);
  const t = audioCtx.currentTime;
  gain.gain.linearRampToValueAtTime(0, t);
  gain.gain.linearRampToValueAtTime(vol, t+0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  osc.start(t);
  osc.stop(t+dur+0.02);
}
function startBGM() {
  if (!audioCtx || muted) return;
  stopBGM();
  const bpm=112, beat=60/bpm;
  const scale=[261.63,293.66,329.63,349.23,392.00,440.00,493.88,523.25];
  let i=0;
  bgmTimer = setInterval(()=>{
    const root = scale[[0,2,4,5][Math.floor(i/4)%4]];
    play(root/2, beat*0.9, 'triangle', 0.12);
    const melody = [0,2,4,5,4,2,0,2, 4,5,7,5,4,2,0, -1,0,2,4,5,4,2,0, 2,4,5,7,9,7,5,4];
    const note = scale[(melody[i%melody.length]+8)%8] || root;
    play(note, beat*0.45, 'sine', 0.16);
    i++;
  }, (beat/2)*1000);
  function play(f,d,t,v){ if(!muted) tone(f,d,t,v); }
}
function stopBGM(){ if (bgmTimer){ clearInterval(bgmTimer); bgmTimer=null; } }
function sfxScore(){ tone(900,0.08,'square',0.18); }
function sfxHit(){ tone(160,0.25,'sawtooth',0.22); tone(100,0.25,'square',0.15); }
function sfxBest(){ tone(1244.5,0.18,'square',0.22); tone(1661.2,0.18,'square',0.12); }
function sfxShield(){ tone(660,0.16,'triangle',0.22); tone(990,0.12,'sine',0.18); }
function sfxDash(){ tone(520,0.12,'sawtooth',0.22); tone(740,0.10,'square',0.12); }

// 生命显示
function renderLives(){
  let hearts=''; for(let i=0;i<lives;i++) hearts+='❤️';
  livesEl.textContent = `· 生命：${hearts||'—'}`;
}

// 小恐龙（绿背白肚皮、眨眼）
const dino = { x: W/2, y: H-78, w: 50, h: 30, speed: 4.4, vx:0 };
function drawDino(x,y, flashing=false){
  c.save(); c.translate(x,y);
  if ((flashing || dashing>0) && Math.floor(perfNow*20)%2===0) { c.globalAlpha = 0.55; }

  // 护盾环
  if (shield>0){
    c.save();
    c.globalAlpha = 0.35 + 0.15*Math.sin(perfNow*6);
    c.strokeStyle = '#7dffa5';
    c.lineWidth = 4;
    c.beginPath(); c.arc(0,-4, 38 + 2*Math.sin(perfNow*4), 0, Math.PI*2); c.stroke();
    c.restore();
  }

  // 身体（绿背）
  c.fillStyle='#3ecf6b'; roundRect(c,-30,-18,64,32,12,true);
  // 白肚皮
  c.fillStyle='#e8fff1'; roundRect(c,-10,-6,38,18,8,true);
  // 头 & 嘴
  c.fillStyle='#3ecf6b'; roundRect(c,22,-26,24,20,8,true);
  c.beginPath(); c.moveTo(46,-18); c.lineTo(60,-14); c.lineTo(46,-10); c.closePath(); c.fill();
  // 手、尾、脚
  c.fillStyle='#3ecf6b'; c.fillRect(-6,-4,8,3);
  c.beginPath(); c.moveTo(-30,-8); c.lineTo(-48,-16); c.lineTo(-30,2); c.closePath(); c.fill();
  c.fillStyle='#c7f7da'; roundRect(c,-12,12,12,4,3,true); roundRect(c,6,12,12,4,3,true);

  // 眼睛/眨眼
  c.fillStyle='#0b0c10';
  const eyeClosed = (blink>0 && blink<0.12);
  if (eyeClosed){ c.fillRect(38,-17,6,2); }
  else { c.beginPath(); c.arc(41,-19,2.4,0,Math.PI*2); c.fill(); }

  c.restore();

  // 冲刺残影
  if (dashing>0){
    c.save();
    c.globalAlpha = 0.15;
    c.filter = 'blur(1px)';
    c.translate(x-10*Math.sign(dino.vx||1), y);
    c.fillStyle='#a9ffd1';
    roundRect(c,-30,-18,64,32,12,true);
    c.restore();
  }
}

// 水果
const FRUIT_TYPES = [
  {name:'apple', w:[26,34], h:20, color:'#ff6b6b', draw:(b)=>{
    c.fillStyle=b.color; roundRect(c,b.x,b.y,b.w,b.h,10,true);
    c.fillStyle='#6ad66a'; c.beginPath(); c.ellipse(b.x+b.w*0.7,b.y-2,5,3,0,0,Math.PI*2); c.fill();
    c.globalAlpha=.2; c.fillStyle='#fff'; roundRect(c,b.x+4,b.y+3,8,6,3,true); c.globalAlpha=1;
  }},
  {name:'banana', w:[30,44], h:12, color:'#ffd166', draw:(b)=>{
    c.fillStyle=b.color; c.beginPath();
    c.moveTo(b.x,b.y+b.h/2);
    c.quadraticCurveTo(b.x+b.w*0.5,b.y-14,b.x+b.w,b.y+b.h/2);
    c.quadraticCurveTo(b.x+b.w*0.5,b.y+10,b.x,b.y+b.h/2);
    c.fill();
  }},
  {name:'orange', w:[24,30], h:24, color:'#ffa62b', draw:(b)=>{
    c.fillStyle=b.color; c.beginPath(); c.arc(b.x+b.w/2,b.y+b.h/2,b.w/2,0,Math.PI*2); c.fill();
    c.fillStyle='#5ec27f'; c.fillRect(b.x+b.w/2-1,b.y-3,2,6);
  }},
  {name:'grape', w:[26,32], h:26, color:'#9b5de5', draw:(b)=>{
    c.fillStyle=b.color; const cx=b.x+b.w/2, cy=b.y+b.h/2, r=b.w*0.18;
    for(let i=0;i<6;i++){ const row=i>>1, col=i%3-1; c.beginPath(); c.arc(cx+col*r*2, cy+(row-0.5)*r*2, r, 0, Math.PI*2); c.fill(); }
    c.fillStyle='#6ad66a'; c.fillRect(cx-1,b.y-4,2,6);
  }},
  {name:'watermelon', w:[32,46], h:20, color:'#ff5c8a', draw:(b)=>{
    c.fillStyle=b.color; c.beginPath();
    c.moveTo(b.x,b.y+b.h); c.lineTo(b.x+b.w,b.y+b.h); c.lineTo(b.x+b.w/2,b.y); c.closePath(); c.fill();
    c.fillStyle='#2dd38a'; c.fillRect(b.x,b.y+b.h-3,b.w,3);
    c.fillStyle='#0b0c10'; for(let i=0;i<4;i++){ c.beginPath(); c.arc(b.x+b.w*(i+1)/5, b.y+b.h*0.7, 1.6, 0, Math.PI*2); c.fill(); }
  }},
];

// 护盾道具外观
function drawShieldItem(b){
  // 绿色六边形 + 闪光
  c.save();
  c.translate(b.x+b.w/2, b.y+b.h/2);
  c.rotate(b.ang);
  const r = b.w/2;
  c.globalAlpha = 0.15; c.beginPath(); c.arc(0,0,r+6,0,Math.PI*2); c.fillStyle='#7dffa5'; c.fill();
  c.globalAlpha = 1; c.beginPath();
  for(let i=0;i<6;i++){ const a=i*Math.PI/3; const px=Math.cos(a)*r, py=Math.sin(a)*r; i?c.lineTo(px,py):c.moveTo(px,py); }
  c.closePath(); c.fillStyle='#43f58f'; c.fill();
  c.restore();
}

function spawnFruit() {
  const t = FRUIT_TYPES[Math.floor(rnd(0, FRUIT_TYPES.length))];
  const w = rnd(t.w[0], t.w[1]);
  const h = t.h;
  const x = rnd(6, W - w - 6);
  const y = -30;
  const vy = rnd(2.2, 3.8) + Math.min(time/30, 3.2);
  const rot = rnd(-0.05,0.05);
  fruits.push({type:t,x,y,w,h,vy,rot,color:t.color, ang:0});
}

function spawnPower(){
  // 概率型：每 2.5~4 秒尝试生成一次，约 45% 生成
  const w = 26, h = 26;
  const x = rnd(10, W-10-w), y = -30;
  const vy = rnd(2.0,3.2) + Math.min(time/35, 2.2);
  const rot = rnd(-0.06,0.06);
  powers.push({kind:'shield', x,y,w,h,vy,rot,ang:0});
}

function reset(){
  dino.x=W/2; dino.vx=0;
  fruits.length=0; powers.length=0;
  spawnTimer=0; powerTimer= rnd(2.5,4.0);
  score=0; time=0; lives = 3; invincible = 0; blink = 0;
  dashing=0; dashCooldown=0; shield=0;
  scoreEl.textContent='0'; renderLives();
  dashFill.style.width = '100%'; shieldFill.style.width='0%';
}

function update(dt){
  time+=dt;
  if (invincible>0) invincible = Math.max(0, invincible - dt);
  if (dashing>0) dashing = Math.max(0, dashing - dt);
  if (dashCooldown>0) dashCooldown = Math.max(0, dashCooldown - dt);
  if (shield>0) shield = Math.max(0, shield - dt);

  // 眨眼：每 2.5~4 秒眨一下
  blink -= dt; if (blink<=-rnd(2.5,4)) blink = 0.18;

  // 控制
  let move=0;
  if (keys.has('ArrowLeft')||keys.has('a')) move-=1;
  if (keys.has('ArrowRight')||keys.has('d')) move+=1;
  if (pointerX!=null){
    const dir=Math.sign(pointerX - dino.x);
    move = Math.abs(pointerX-dino.x)<4 ? 0 : dir;
  }

  // 冲刺触发（按住 Shift）
  if ((keys.has('Shift') || keys.has('ShiftLeft') || keys.has('ShiftRight')) && dashing<=0 && dashCooldown<=0){
    dashing = DASH_DURATION; dashCooldown = DASH_COOLDOWN; sfxDash();
  }

  const speedMul = dashing>0 ? 2.0 : 1.0;
  dino.vx = move * dino.speed * speedMul;
  dino.x += dino.vx;
  dino.x = Math.max(34, Math.min(W-34, dino.x));

  // 生成水果（难度递增）
  spawnTimer -= dt;
  const interval = Math.max(0.22, 0.9 - time*0.02);
  if (spawnTimer<=0){ spawnFruit(); spawnTimer = interval; }

  // 生成护盾道具
  powerTimer -= dt;
  if (powerTimer<=0){
    if (Math.random()<0.45) spawnPower();
    powerTimer = rnd(2.5,4.0);
  }

  // 更新坠落物
  fruits.forEach(b=>{ b.y+=b.vy; b.ang=(b.ang||0)+(b.rot||0); });
  powers.forEach(p=>{ p.y+=p.vy; p.ang=(p.ang||0)+(p.rot||0); });

  // 移除越界 + 计分
  const before = fruits.length;
  fruits = fruits.filter(b=> b.y <= H+40 );
  const removed = before - fruits.length;
  if (removed>0){
    score += removed; scoreEl.textContent = score; sfxScore();
    if (score > best){ best = score; bestEl.textContent = best; localStorage.setItem('dino_highscore', best); sfxBest(); }
  }
  powers = powers.filter(p=> p.y <= H+40);

  // 吃到护盾
  for (let i=powers.length-1;i>=0;i--){
    const p = powers[i];
    if (hitBox(dino.x,dino.y,dino.w,dino.h, p.x+p.w/2,p.y+p.h/2,p.w,p.h,0.8)){
      shield += SHIELD_GAIN; // 可叠加
      sfxShield();
      powers.splice(i,1);
    }
  }

  // 与水果碰撞（冲刺/护盾/无敌期间免疫）
  if (invincible<=0 && shield<=0 && dashing<=0){
    for (let b of fruits){
      const bx=b.x+b.w/2, by=b.y+b.h/2;
      if (hitBox(dino.x,dino.y,dino.w,dino.h, bx,by,b.w,b.h,0.78)){
        onHit(); break;
      }
    }
  }

  // HUD 进度条
  dashFill.style.width = `${(1 - dashCooldown/DASH_COOLDOWN)*100}%`;
  shieldFill.style.width = `${Math.min(1, shield/SHIELD_GAIN)*100}%`;
}

function draw(){
  c.clearRect(0,0,W,H);
  // 背景网格
  c.globalAlpha=.06; for(let y=0;y<H;y+=22) c.fillRect(0,y,W,1); c.globalAlpha=1;

  // 恐龙
  drawDino(dino.x, dino.y, invincible>0);

  // 水果
  fruits.forEach(b=>{
    c.save(); c.translate(b.x+b.w/2, b.y+b.h/2); c.rotate(b.ang||0); c.translate(-b.w/2, -b.h/2);
    b.type.draw({x:0,y:0,w:b.w,h:b.h,color:b.color});
    c.restore();
  });

  // 道具
  powers.forEach(p=>{
    c.save(); drawShieldItem(p); c.restore();
  });

  // 难度条
  c.globalAlpha=.3; c.fillRect(10, H-12, Math.min(1, time/30)*(W-20), 4); c.globalAlpha=1;
}

function hitBox(px,py,pw,ph, bx,by,bw,bh, k=1){
  return Math.abs(px - bx) < (pw/2 + bw/2)*k &&
         Math.abs(py - by) < (ph/2 + bh/2)*k;
}

function onHit(){
  lives -= 1; renderLives(); sfxHit();
  invincible = 1.2;
  // 轻微清屏，避免连击
  fruits = fruits.filter(b=> b.y < dino.y - 40);
  if (lives<=0){ gameOver(); }
}

function gameOver(){
  state='dead';
  stopBGM();
  const isBest = score>=best;
  if (isBest){ best = score; bestEl.textContent = best; localStorage.setItem('dino_highscore', best); }
  msgEl.innerHTML = `游戏结束！分数：<b>${score}</b> · 最高分：<b>${best}</b>（R重开）`;
  overlay.classList.add('show');
}

function startGame(){
  reset();
  state='play';
  overlay.classList.remove('show');
  if (!audioCtx) initAudio();
  if (audioCtx.state==='suspended') audioCtx.resume();
  if (!muted) startBGM();
}

// 圆角矩形工具
function roundRect(ctx,x,y,w,h,r,fill){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  fill ? ctx.fill() : ctx.stroke();
}

// 事件
document.addEventListener('keydown', e=>{
  if (e.key==='r'||e.key==='R'){ startGame(); return; }
  if (e.key===' '){ togglePause(); return; }
  keys.add(e.key);
});
document.addEventListener('keyup', e=>keys.delete(e.key));

const touch = (x)=>{ const rect=canvas.getBoundingClientRect(); pointerX = x - rect.left; };
canvas.addEventListener('pointerdown', e=>touch(e.clientX));
canvas.addEventListener('pointermove', e=>{ if (e.buttons) touch(e.clientX); });
window.addEventListener('pointerup', ()=>{ pointerX=null; });

startBtn.addEventListener('click', ()=>{
  initAudio(); audioCtx.resume(); startGame();
});

function togglePause(){
  if (state==='play'){ state='pause'; stopBGM(); overlay.classList.add('show'); msgEl.textContent='已暂停（空格继续）'; }
  else if (state==='pause'){ state='play'; overlay.classList.remove('show'); if(!muted) startBGM(); }
}
pauseBtn.addEventListener('click', togglePause);

muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? '🔇' : '🔊';
  if (muted) { stopBGM(); }
  else { if (!audioCtx) initAudio(); audioCtx.resume(); startBGM(); }
});

// 主循环
let perfNow = 0;
function loop(ts){
  if (!loop.last) loop.last=ts;
  const dt = Math.min(0.033,(ts-loop.last)/1000);
  loop.last=ts; perfNow = ts/1000;

  if (state==='play'){ update(dt); draw(); }
  requestAnimationFrame(loop);
}
renderLives();
overlay.classList.add('show');
draw();
requestAnimationFrame(loop);
</script>
</body>
</html>
